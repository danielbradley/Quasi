-	Semi - a tool for semi-literate programming
--	Daniel Bradley @ CrossAdaptive

,	Copyright

Copyright 2011, Daniel Robert Bradley.

,	License

This software is released under the terms of the GPLv3.

Download from:
~
http://www.crossadaptive.com/download/Semi/semi-1.0.2.tar.bz2
~

,	Source

View source:
~
http://semiliterateprogramming.org/semi.mtx.txt
~

,	Disclaimer

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.	Introduction

Donald Knuth coined the term "literate programming" to refer to a programming approach whereby a programmer develops a program "in the order demanded by logic and flow of their thoughts" [Wikipedia].
The programmer produces human language prose in a flow intended to be best promote understanding, the a reader, of encoded code fragments embedded within the text.

Tools can then be used to produce reader friendly documentation /woven/ from the source, as well as executable/compilable /tangled/.
Knuth's original tool was called "Web" [Web], however other tools have since been developed that are language-agnostic [Noweb].

The following code fragment from the literate programming Wikipedia page demonstrates how the web system worked [Wikipedia].
The text "<<Scan File>>=" defines a /macro/ that has associated with it the code following.

~
	<<Scan file>>=
	while (1) {
		<<Fill buffer if it is empty; break at end of file>>
		c = *ptr++;
		if ( c > ' ' && c < 0177 ) {
			/* visible ASCII codes */
			if ( !in_word) {
				word_count++;
				in_word = 1;
			}
			continue;
		}
		if ( c == '\n' ) line_count++;
		else if ( c != ' ' && c != '\t') continue;
		in_word = 0;
			/* c is newline, space, or tab */
	}
	@
~

The macro "<<Scan File>>" could then be used in any other code /chunk/.

A problem with such an approach is the possibility that the while a reader think they understand the code they are reading, it may be the case that they are not noticing a specific interaction between various code chucks.
It would be necessary for the reader to reference the /tangled/ code, in order to be sure they are properly understanding interactions with the system.

A related problem is that the system does not impose any limitations on to what degree macros are used.
The system provides the ability for code to be intermixed in arbitrary ways.
Software developed using the system may become increasingly hard to maintain as others are forced edit the source files.

The paper describes Semi, a tool for semi-literate programming.
It has been developed in the spirit of Knuth's literate programming but, by providing a far less powerful tool, it also simplifies the process from the perspective of a maintenance programmer.

.	Background

While this tool was inspired by literate programming, it is derived from an earlier tool called "extract" that is used for extracting SQL definitions from web-application requirements documents for using in database initialise scripts.
The tool would scan text files and extract the text of pre-formatted sections that matched a user supplied pattern.

For example, this command would extract the following block of SQL:
~
extract -p "users_table" source_file.txt >> output_file.sql
~

~
	~users_table~
	CREATE TABLE users
	(
	USER        INT(11)  NOT NULL AUTO_INCREMENT
	PRIMARY KEY (USER)
	);
	~
~ 

This allowed the definitions of SQL tables and SQL Stored Procedures to be directly developed and documented within the requirements document.
This provided the motivation for developing a similar tool to also extract source code from documentation.

.	Concept

Similar to "extract", "semi" extracts sections of pre-formatted text from documentation and appends it to /target/ text files.
Unlike "extract" rather than matching a supplied pattern, the /identifier/ in the pre-formatted text section is used as the file path of the target file relative to a user supplied base directory.

For example, this command would extract the following block of source code and append it to the file 'source/c/semi.c':
~
	semi source source/mtx/semi.mtx
~

~
	~c/semi.c~
	int main( int argc, char** argv )
	{
		return 0;
	}
	~
~

The tool does sanitation of the filenames, ensuring that parent directory ('..') commands aren't included and therefore that output files remain under the specified base directory.
If the specified base directory already exists the tool will exit with an error, unless the '-f' flag is passed as the first command argument.
~
	semi -f source source/mtx/semi.mtx
~

If the identifier of the pre-formatted block section is prefixed by an exclamation mark the file is truncated on opening.
It is advisable that when a file is truncated in this manner that the code fragment be a comment warning that the file is generated:
~
	~!c/semi.c~
	/*   !!!   Warning this file is auto-generated   !!!   */
	~
~

Semi is implemented to process text files that use the MaxText text format [MaxText].
If certain code fragments are not desired in the output documentation they can be commented using the standard MaxText commenting character, but will still be processed properly by Semi.
This is useful for hiding code comments, or perhaps includes.
~
	!
	Include various standard includes.

	~!c/semi.c!~
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	~
	!
~

The key difference between literate programming tools and Semi is that Semi forces the programmer to construct all target source files in a linear fashion.
However, as files may be constructed in parallel.
It is thought that the key benefit of this approach is that it will enable programmers to better modularise their software as their is very little overhead in creating new files.

.	Example: semi implementation

Semi has now been reimplemented using an earlier version of semi.
This version has been rewritten in pure C to maximise portability, allowing it to act as the foundation of an organisation's development tool set.

~!c/main.c~
/*   !!!   Warning generated from mtx source files   !!!   */
~

!
~c/main.c~
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <errno.h>
#include <dirent.h>
#include <libgen.h>
~
!

..		Invocation

To ensure simplicity of implementation, Semi is invoked with a simple command-line.

~
	semi [-f] BASE_DIR INPUT_FILES...
~

The /BASE DIR/ argument specifies the directory that target files are created relative to -- if the /BASE DIR/ already exists Semi exits returning an error unless the '-f' flag is passes as the first argument.
After the /BASE DIR/ one or more input files are specified for parsing.

..		Overview

The function declarations below show the overall structure of Semi.
First the arguments are processed (*processArguments*) and if valid the base directory is verified (*canAccessBaseDirectory*) and created if needed.
Each of the command-line arguments corresponding to the source files are then processed (*processSourceFile*).
During processing the output files are opened and closed (*rejig*) as necessary.
Each time a target file is created the filename must be appropriately sanitised (*generateSafeFilepath*), and it must be determined whether to truncate the file or not (*doWeTruncate*).

~c/main.c~
int        processArguments( int argc, const char** argv );
int  canAccessBaseDirectory( const char* baseDir, int forced );
int      processSourceFiles( const char* baseDir, int first, int last, const char** files );
FILE*                 rejig( FILE* out, const char* baseDir, const char* line );
char*  generateSafeFilepath( const char* basedir, const char* line );
int            doWeTruncate( const char* line );
~

If in appropriate arguments are passed Semi prints a usage message (*usage*) and exits with an error (-1).
Similarly if the /base dir/ directory already exists Semi prints an error message (*errorDirectoryExists*) and exists with an error (-1).

~c/main.c~
int                   usage();
int    errorDirectoryExists();
~

The following utility functions are also used (these are described in the appendix).

~c/main.c~
int       createDirectories(       char* safeFilePath );
int         directoryExists( const char* path );
char*       parentDirectory( const char* filepath );
char*              readline( FILE* stream );
char*            stringCopy( const char* aString );
~

During argument processing the following global variables are initialised.
/FORCE/ is initialised as true (1) if the '-f' flag was passed; FIRST is initialised to indicate the first source file argument in /argv/; and /BASE_DIR/ is initialised to the base directory argument.

~c/main.c~
int         FORCE;
int         FIRST;
const char* BASE_DIR;
~

The main function acts as a coordinator, calling the appropriate functions as needed.

~c/main.c~
int main( int argc, const char** argv )
{
	int status = 0;

	if ( processArguments( argc, argv ) )
	{
		if ( canAccessDirectory( BASE_DIR, FORCE ) )
		{
			int last = argc - 1;
			status = processSourceFiles( BASE_DIR, FIRST, last, argv );
		}
		else
		{
			status = errorDirectoryExists();
		}
	}
	else
	{
		status = usage();
	}
	return !status;
}
~


..		Argument processing


If the minimum expected number of arguments is supplied the arguments are processed.
If the force argument is supplied, the global variable /FORCE/ is set to true (1);
then the global variable /BASE_DIR/ is initialised to the next argument.
Finally, if there is at least one file argument remaining, the global variable /FIRST/ is initialised to identify it and the function will returns true (1).

~c/main.c~
int processArguments( int argc, const char** argv )
{
	int status             = 0;
	int expected_arguments = 3;
	int i                  = 1;

	if ( argc >= expected_arguments )
	{
		if ( 0 == strcmp( argv[i], "-f" ) )
		{
			expected_arguments++;
			i++;
			FORCE = 1;
		}
		BASE_DIR = argv[i]; i++;
		FIRST    = i;
		status   = ( argc >= expected_arguments );
	}
	return status;	
}
~


..		Accessing the base directory

It is attempted to create the base directory.
If this succeeds success is returned (1), else failure is returned (0), unless the force argument is true.

~c/main.c~
int canAccessDirectory( const char* baseDir, int force )
{
	int status = 0;

	if ( mkdir( baseDir, 0755 ) )
	{
		switch ( errno )
		{
		case EEXIST:
			status = force;
			break;
		default:
			status = 1;
		}
	}
	return status;
}
~

..		Processing the source files

For each source file the *processFile* function is called passing the /baseDir/ and the /source file/.

~c/main.c~
int processSourceFiles( const char* baseDir, int first, int last, const char** files )
{
	int status = 1;
	int i;
	for ( i=first; i <= last; i++ )
	{
		status &= processFile( baseDir, files[i] );
	}
	return status;
}
~

...			Processing a file

This procedure processes an individual source file.
The file stream *in* is opened for the duration of the procedure, while the *out* file stream is only opened while it is processing a pre-formatted text block.

The procedure reads lines from the *in* stream, using the "readline" procedure.
When a tilde (~) character is encountered the system either opens, or closes, *out* by calling the "rejig" function, which rejigs the *out* stream.
Each time a stream is closed a blank line is printed to the stream -- this allows the source to have spaces between chunks, while not having kludge whitespace in pre-formatted text blocks.

When a tilde character doesn't start the line and the *out* stream is an open (not NULL) stream, the line is written out to the stream.

At the end of the while loop if the /out/ file stream is not null it indicates that the previous pre-formatted block wasn't closed properly.
This causes a warning message to be printed to /stderr/ and function returns false.

~c/main.c~
int processFile( const char* baseDir, const char* sourceFile )
{
	int status = 0;
	fprintf( stdout, "Processing: %s\n", sourceFile );

	FILE* in = fopen( sourceFile, "r" );
	if ( in )
	{
		FILE* out = NULL;

		char* line;
		while ( (line = readline( in )) )
		{
			if ( '~' == line[0] ) {
				out = rejig( out, baseDir, line );
				if ( out ) fprintf( out, "\n", line );
			}
			else if ( out )
			{
				fprintf( out, "%s", line );
			}
		}
		fclose( in );

		if ( out )
		{
			fclose( out );
			fprintf( stderr, "Warning: %s is unmatched '~'\n", sourceFile );
		}
		status = (out == NULL);
	}

	return status;
}
~

...			Rejig file output

This function determines whether the passed line contains a valid filename by calling "generateSafeFilepath", then creates any required directories, then opens and returns an appropriate file stream.

~c/main.c~
FILE* rejig( FILE* out, const char* basedir, const char* line )
{
	FILE* ret = NULL;

	if ( out ) fclose( out );

	char* safeFilePath = generateSafeFilepath( basedir, line );
	if ( safeFilePath && createDirectories( parentDirectory( safeFilePath ) ) )
	{
		if ( doWeTruncate( line ) )
		{
			ret = fopen( safeFilePath, "w" );
		}
		else
		{
			ret = fopen( safeFilePath, "a" );
		}
	}
	free( safeFilePath );

	return ret;
}
~

...			Generation of the safe filepath

The "generateSafeFilepath" procedure attempts to produce a safe file path from combining the base-dir with a file path extracted from the passed line.
The passed line starts with a tilde character, but may have anything else as well.

First the line is checked to make sure it doesn't include '..', which would allow accessing paths above the base dir.
Next 'strtok' is used to tokenise the line using the tilde as a delimiter.
The first token returned is treated as the filename -- first it is checked to make sure it is alpha-numerical chacter (indicating an appropraite filename), then strtok is called again to verify that the token is trailed by another tilde.

If there are any problems NULL is returned.

~c/main.c~
char* generateSafeFilepath( const char* basedir, const char* line )
{
	char* full = NULL;
	{
		int len = strlen( basedir ) + strlen( line ) + 1;
		if ( NULL == strstr( line, ".." ) )
		{
			char* test  = stringCopy( line );	
			char* token = strtok( test, "~" );

			if ( token && ('!' == token[0]) ) token++;

			if ( token && isalnum( token[0] ) )
			{
				full = calloc( len, sizeof( char ) );
				strcpy( full, basedir );
				strcat( full, "/" );
				strcat( full, token );

				if ( NULL == strtok( NULL, "~" ) )
				{
					free( full );
					full = NULL;
				}
			}
			free( test );
		}
	}
	return full;
}
~

...			Truncation

The output file should be truncated if the source file name is proceeded by an exclamation mark.

~c/main.c~
int doWeTruncate( const char* line )
{
	int truncate = 0;
	if ( 2 < strlen( line ) )
	{
		truncate = ('!' == line[1]);
	}
	return truncate;
}
~

..		Error messages

...			Incorrect arguments

If the program is invoked without the appropriate arguments the following usage message is printed to /stderr/.
~
Usage:
	semi [-f] BASE_DIR INPUT_FILES
~

~c/main.c~
int usage()
{
	const char* ch = "Usage:\n\t semi [-f] BASE_DIR INPUT_FILES";
	fprintf( stderr, "%s\n", ch );
	return -1;
}
~

...			Directory already exists

If the force ('-f') flag hasn't been passed, and the base directory already exists the following error message is printed to /stderr/.
~
	Error: directory already exists, or cannot be created!
~

~c/main.c~
int errorDirectoryExists()
{
	const char* ch = "Error: directory already exists, or cannot be created!";
	fprintf( stderr, "%s\n", ch );
	return -1;
}
~

.	Future Work

In the future we plan to rewrite and release our other open source projects, such as MaxText and Build, using Semi.

,	Appendix A

Semi uses the following generic auxiliary functions.

..	Create directories

This is a recursive procedure that finds the first existing directory, then unwinds creating the necessary directories.

~c/main.c~
int createDirectories( char* dir )
{
	int success = 1;
	if ( ! directory_exists( dir ) )
	{
		if ( createDirectories( parentDirectory( dir ) ) )
		{
			success = ! mkdir( dir, 0755 );
		}
	}
	free( dir );
	return success;
}
~

..	Directory exists

A simple procedure that determines whether a directory exists or not.

~c/main.c~
int directory_exists( const char* path )
{
	int status = 0;
	DIR* dir = opendir( path );
	if ( dir )
	{
		closedir( dir );
		status = 1;
	}
	return status;
}
~

..	Parent directory

A simple wrapper around "dirname" that allocates and returns a string.

~c/main.c~
char* parentDirectory( const char* filepath )
{
	char* ret = calloc( strlen( filepath ) + 1, sizeof( char ) );
	{
		strcpy( ret, filepath );
		strcpy( ret, dirname( ret ) );
	}
	return ret;
}
~

..		Read line

The "readline" procedure reads individual characters into a character buffer --
each character is appended to the char string "line".
When a newline character is encountered "line" is returned.
When the stream is empty a NULL is returned.

~c/main.c~
char* readline( FILE* stream )
{
	int  n = 0;
	char ch[2] = { 0, 0 };
	char* line = calloc( 1024, sizeof( char ) );

	int read;
	do
	{
		read = fread( ch, sizeof(char), 1, stream );
		if ( read )
		{
			switch ( *ch )
			{
			case '\n':
				line[n++] = *ch;
				read = 0;
				break;
			default:
				line[n++] = *ch;
			}
		}
	}
	while ( 0 != read );

	if ( 0 == n )
	{
		free( line );
		line = NULL;
	}

	return line;
}
~

..		String copy

Returns a copy of the passed string.

~c/main.c~
char* stringCopy( const char* aString )
{
	char* copy = calloc( strlen( aString) + 1, sizeof( char ) );
	strcpy( copy, aString );
	return copy;
}
~

,	Bibliography

[Wikipedia]	Wikipedia: literate programming.
		http://en.wikipedia.org/wiki/Literate_programming

[Web]		The CWEB System of Structured Documentation
		http://www-cs-faculty.stanford.edu/~uno/cweb.html

[Noweb]		Noweb - A Simple, Extensible Tool for Literate Programming
		http://www.cs.tufts.edu/~nr/noweb/

