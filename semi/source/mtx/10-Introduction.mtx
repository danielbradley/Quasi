.	Introduction

Donald Knuth coined the term "literate programming" to refer to a programming approach whereby a programmer develops a program "in the order demanded by logic and flow of their thoughts" [Wikipedia].
The programmer produces human language prose in a flow intended to be best promote understanding, the a reader, of encoded code fragments embedded within the text.

Tools can then be used to produce reader friendly documentation /woven/ from the source, as well as executable/compilable /tangled/.
Knuth's original tool was called "Web" [Web], however other tools have since been developed that are language-agnostic [Noweb].

The following code fragment from the literate programming Wikipedia page demonstrates how the web system worked [Wikipedia].
The text "<<Scan File>>=" defines a /macro/ that has associated with it the code following.

~
	<<Scan file>>=
	while (1) {
		<<Fill buffer if it is empty; break at end of file>>
		c = *ptr++;
		if ( c > ' ' && c < 0177 ) {
			/* visible ASCII codes */
			if ( !in_word) {
				word_count++;
				in_word = 1;
			}
			continue;
		}
		if ( c == '\n' ) line_count++;
		else if ( c != ' ' && c != '\t') continue;
		in_word = 0;
			/* c is newline, space, or tab */
	}
	@
~

The macro "<<Scan File>>" could then be used in any other code /chunk/.

A problem with such an approach is the possibility that the while a reader think they understand the code they are reading, it may be the case that they are not noticing a specific interaction between various code chucks.
It would be necessary for the reader to reference the /tangled/ code, in order to be sure they are properly understanding interactions with the system.

A related problem is that the system does not impose any limitations on to what degree macros are used.
The system provides the ability for code to be intermixed in arbitrary ways.
Software developed using the system may become increasingly hard to maintain as others are forced edit the source files.

The paper describes Semi, a tool for semi-literate programming.
It has been developed in the spirit of Knuth's literate programming but, by providing a far less powerful tool, it also simplifies the process from the perspective of a maintenance programmer.

