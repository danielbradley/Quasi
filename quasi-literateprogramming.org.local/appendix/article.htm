<article>
<h1>Appendix A</h1>
<p class='paragraph'>
Quasi uses the following generic auxiliary functions.
</p>
<h2>Create directories</h2>
<p class='paragraph'>
This is a recursive procedure that finds the first existing directory, then unwinds creating the necessary directories.
</p>
<pre>
int createDirectories( char* dir )
{
	int success = 1;
	if ( ! directory_exists( dir ) )
	{
		if ( createDirectories( parentDirectory( dir ) ) )
		{
			success = ! mkdir( dir, 0755 );
		}
	}
	free( dir );
	return success;
}
</pre>
<h2>Directory exists</h2>
<p class='paragraph'>
A simple procedure that determines whether a directory exists or not.
</p>
<pre>
int directory_exists( const char* path )
{
	int status = 0;
	DIR* dir = opendir( path );
	if ( dir )
	{
		closedir( dir );
		status = 1;
	}
	return status;
}
</pre>
<h2>Parent directory</h2>
<p class='paragraph'>
A simple wrapper around "dirname" that allocates and returns a string.
Note: due to <i>dirname</i> returning its own storage, can't just call:
</p>
<pre>
	return stringcopy( dirname( filepath ) );
</pre>
<pre>
char* parentDirectory( const char* filepath )
{
	char*  ret = stringCopy( filepath );
	strcpy( ret, dirname( ret ) );
	return ret;
}
</pre>
<h2>Read line</h2>
<p class='paragraph'>
The "readline" procedure reads individual characters into a character buffer --
each character is appended to the char string "line".
When a newline character is encountered "line" is returned.
When the stream is empty a NULL is returned.
</p>
<p class='paragraph'>
If the line is longer than 1023 characters the buffer "line" is doubled in size using "realloc".
</p>
<p class='paragraph'>
Easier to implement this, than worry about portability.
From memory, the POSIX function is implemented differently on different systems.
</p>
<pre>
char* readline( FILE* stream )
{
	int  n     = 0;
	int  sz    = 1024;
	char ch[2] = { 0, 0 };
	char* line = calloc( sz, sizeof( char ) );

	int read;
	do
	{
		read = fread( ch, sizeof(char), 1, stream );
		if ( read )
		{
			switch ( *ch )
			{
			case '\n':
				line[n++] = *ch;
				line[n]   = '\0';
				read      = 0;
				break;
			default:
				line[n++] = *ch;
				line[n]   = '\0';
			}

			if ( n == sz )
			{
				sz  *= 2;
				line = realloc( line, sz );
			}
		}
		
	}
	while ( 0 != read );

	if ( 0 == n )
	{
		free( line );
		line = NULL;
	}

	return line;
}
</pre>
<h2>String copy</h2>
<p class='paragraph'>
Returns a copy of the passed string.
</p>
<pre>
char* stringCopy( const char* aString )
{
	char* copy = calloc( strlen( aString) + 1, sizeof( char ) );
	strcpy( copy, aString );
	return copy;
}
</pre>
</article>
